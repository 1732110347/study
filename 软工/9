  9.1   面向对象方法学概述

9.1.1.面向对象方法学的要点
(1)面向对象的软件系统是由对象组成的，软件中的任何元素都是对象。
(2)把所有对象都划分成各种对象类(简称为类)，每个对象类都定义了一组数据和一组方法。
(3)按照子类与父类的关系，把若干个对象类组成一个层次结构的系统。
(4)对象彼此之间仅能通过传递消息互相联系。

9.1.2.面向对象方法学的优点
1.与人类习惯的思维方法一致
2.稳定性好
3.可重用性好
4.较易开发大型软件产品
5.可维护性好

9.2   面向对象的概念
9.2.1.对象
1.对象的形象表示
使用对象时只需知道它向外界提供的接口形式而无须知道它的内部实现算法，这使对象的使用变得简单、方便，而且具有很高的安全性和可靠性。

2.对象的定义
       (1) 定义1： 对象是具有相同状态的一组操作的集合。
    
    (2) 定义2： 对象是对问题域中某个东西的抽象，这种抽象反映了系统保存有关这个东西的信息或与它交互的能力。也就是说，对象是对属性值和操作的封装。
    
    (3) 定义3： 对象∷=〈ID,MS,DS,MI〉。其中，ID是对象的标识或名字，MS是对象中的操作集合，DS是对象的数据结构，MI是对象受理的消息名集合(即对外接口)。

2.对象的定义
    对象是封装了数据结构及可以施加在这些数据结构上的操作的封装体，这个封装体唯一标识符，而且向外界提供一组服务。
        对象中的数据表示对象的状态，一个对象的状态只能由该对象的操作来改变。
        每当需要改变对象的状态时，只能由其他对象向该对象发送消息。
        对象响应消息时，按照消息模式找到与之匹配的方法，并执行该方法。

3.对象的特点
(1) 以数据为中心。操作围绕对其数据所需要做的处理来设置。
(2) 对象是主动的。它是进行处理的主体。不能从外部直接加工它的私有数据，必须通过公有接口执行某个操作来处理私有数据。
(3) 实现了数据封装。对象的私有数据对外是隐藏的、不可见的，只能通过公有的操作访问或处理。
(4) 本质上具有并行性。不同对象各自独立地处理自身的数据，彼此通过发消息传递信息完成通信。
(5) 模块独立性好。对象内部结合紧密，内聚性高。对象之间的耦合比较松。


9.2.2 面向对象的其他概念
1.类（class）
“类”就是对具有相同数据和相同操作的一组相似对象的定义，也就是说，类是对具有相同属性和行为的一个或多个对象的描述。

2.实例（instance）
实例就是由某个特定的类所描述的一个具体的对象。
类是抽象的，实例是具体的。

“对象” 既可以指一个具体的对象，也可以泛指一般的对象。
“实例”必然是指一个具体的对象。

3. 消息（massage）
消息就是要求某个对象执行在定义它的那个类中所定义的某个操作的规格说明。

4. 方法（method）
    方法就是对象所能执行的操作，描述了对象执行操作的算法，响应消息的方法。

5. 属性（attribute）
    属性就是类中所定义的数据，它是对客观世界实体所具有的性质的抽象。类的每个实例都有自己特有的属性值。
    例如，Circle类中定义的代表圆心坐标、半径、颜色等的数据成员，就是圆的属性。

6.封装（encapsulation）
    封装是指把数据和实现操作的代码集中起来放在对象内部，对外界隐藏对象的实现细节。
    对象具有封装性的条件：
    (1) 有一个清晰的边界。所有私有数据和实现操作的代码都被封装在这个边界内。
    (2) 有确定的接口。这些接口就是对象可以接受的消息，只能通过向对象发送消息来使用它。
    (3) 受保护的内部实现。实现对象功能的细节不能在定义该对象的类的范围外访问。

7.继承（inheritance）
    继承是子类自动地共享基类中定义的数据和方法的机制。
    一个类的上层可以有父类，下层可以有子类。这种层次结构系统的一个重要性质是继承性，一个类直接继承其父类的全部描述(数据和操作)。

继承具有传递性，即一个类实际上继承了它所在的类等级中在它上层的全部基类的所有描述。
当类等级为树形结构时，类的继承是单继承；当允许一个类有多个父类时，类的继承是多重继承。
当需要扩充原有的功能时，派生类的方法可以调用其基类的方法，并在此基础上增加必要的程序代码；当需要完全改变原有操作的算法时，可以在派生类中实现一个与基类方法同名而算法不同的方法；当需要增加新的功能时，可以在派生类中实现一个新的方法。
有了继承性可以用把已有的一般性的解加以具体化的办法，来达到软件重用的目的。

8.多态性（polymorphism）
    多态性是指子类对象可以像父类对象那样使用，同样的消息既可以发送给父类对象也可以发送给子类对象。即，在类等级的不同层次中可以共享(公用)一个行为(方法)的名字，然而不同层次中的每个类却各自按自己的需要来实现这个行为。

9.重载（overloading）
        有两种重载：函数重载是指在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名字；运算符重载是指同一个运算符可以施加于不同类型的操作数上面。
    

9.3   面向对象模型
描述系统数据结构的对象模型，
描述系统控制结构的动态模型和
描述系统功能的功能模型。
一个典型的软件系统使用数据结构(对象模型)，执行操作(动态模型)，并且完成数据值的变化(功能模型)。

对象模型是最重要、最基本、最核心的。

9.4   对象模型

对象模型是对模拟客观世界实体的对象以及对象彼此间的关系的映射，描述了系统的静态结构。

对象模型为建立动态模型和功能模型，提供了实质性的框架。

建立对象模型，需要用适当的建模语言来表达模型，建模语言由记号和使用记号的规则组成。通常使用UML提供的类图来建立对象模型。

9.4.1.类图的基本符号
1.定义类
为类命名时遵守的准则：
使用标准术语；
使用具有确切含义的名词；
必要时用名词短语作名字。

2.定义属性
UML描述属性的语法格式如下：
可见性属性名： 类型名=初值{性质串}

属性的可见性（即可访问性）通常有下述3种：public、private和protected，分别用+、-和#表示。没有默认的可见性。
属性名和类型名之间用冒号(:)分隔。类型名表示该属性的数据类型，它可以是基本数据类型，也可以是用户自定义的类型。
类型名和初值之间用等号（=）隔开。初值可作为创建实例时属性的默认值。

{性质串}明确地列出该属性所有可能的取值。
也可以用{性质串}说明属性的其他性质，例如，约束说明{只读}表明该属性是只读属性。

类的属性中还可以有一种能被该类所有对象共享的属性，称为类的作用域属性，也称为类变量。

3.定义服务
  服务也就是操作，UML描述操作的语法格式如下：
    可见性操作名（参数表）： 返回值类型{性质串}
操作可见性的定义方法与属性相同。
参数表是用逗号分隔的形式参数的序列。描述一个参数的语法如下：
参数名： 类型名=默认值
当操作的调用者未提供实在参数时，该参数就使用默认值。
与属性类似，在类中可定义类作用域操作，在类图中表示为带下划线的操作。这种操作只能存取本类的类作用域属性。

9.4.2.表示关系的符号

  类与类之间通常有关联、泛化(继承)、依赖和细化4种关系。
1.关联
      关联表示两个类的对象之间存在某种语义上的联系。
(1) 普通关联
       只要在类与类之间存在连接关系就可以用普通关联表示。普通关联的图示符号是连接两个类之间的直线，如下图所示。
在表示关联的直线两端可以写上重数（multiplicity），它表示该类有多少个对象与对方的一个对象连接。重数的表示方法通常有：


2.聚集
    聚集也称为聚合，是关联的特例。聚集表示类与类之间的关系是整体与部分的关系。有共享聚集和组合聚集两种特殊的聚集关系。
(1) 共享聚集
    共享聚集:在聚集关系中处于部分方的对象可同时参与多个处于整体方对象的构成。下图中，一个课题组包含许多成员，
    每个成员又可以是另一个课题组的成员，则课题组和成员之间是共享聚集关系。

(2) 组合聚集
    组合聚集（组成）:如果部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失。

3.泛化
    UML中的泛化关系就是通常所说的继承关系，它是通用元素和具体元素之间的一种分类关系。具体元素完全拥有通用元素的信息，并且还可以附加一些其他信息。
    
    泛化关系指出在类与类之间存在“一般--特殊”关系。泛化可进一步划分成普通泛化和受限泛化。   

(1) 普通泛化
图示抽象类时，在类名下方附加一个标记值{abstract}。

    抽象类通常都具有抽象操作。抽象操作仅用来指定该类的所有子类应具有哪些行为。抽象操作的图示方法与抽象类相似，在操作标记后面跟随一个性质串{abstract}。


4.依赖和细化
(1) 依赖关系
    依赖关系描述两个模型元素（类、用例等）之间的语义连接关系： 其中一个模型元素是独立的，另一个模型元素不是独立的，它依赖于独立的模型元素，如果独立的模型元素改变了，将影响依赖于它的模型元素。

(2) 细化关系
    当对同一个事物在不同抽象层次上描述时，这些描述之间具有细化关系。
    假设两个模型元素A和B描述同一个事物，它们的区别是抽象层次不同，如果B是在A的基础上的更详细的描述，则称B细化了A，或称A细化成了B。
    细化用来协调不同阶段模型之间的关系，表示各个开发阶段不同抽象层次的模型之间的相关性，常常用于跟踪模型的演变。


9.5   动态模型
动态模型表示瞬时的、行为化的系统的“控制”性质，它规定了对象模型中的对象的合法变化序列。

 状态与事件密不可分，一个事件分开两个状态，一个状态隔开两个事件。事件表示时刻，状态代表时间间隔。
       通常用UML提供的状态图来描绘对象的状态、触发状态转换的事件以及对象的行为（对事件的响应）。
       每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起来，从而构成系统的动态模型。
       也就是说，动态模型是基于事件共享而互相关联的一组状态图的集合。

9.6 功能模型
功能模型表示变化的系统的“功能”性质，它指明系统应该“做什么”，因此更直接地反映了用户对目标系统的需求。传统的功能模型由一组数据流图组成。
       UML的用例图是进行需求分析和建立功能模型的强有力工具。用用例图建立起来的系统模型称为用例模型。使用用例模型代替传统的功能说明，往往能够更好地获取用户需求。
       用例模型描述的是外部行为者所理解的系统功能，它所回答的问题是“系统应该为每个用户做什么”。
       用例模型的建立是系统开发者和用户反复讨论的结果，它描述了开发者和用户对需求规格所达成的共识。

9.6.1.用例图

一幅用例图包含系统、行为者、用例及用例之间的关系。

图中的方框代表系统，椭圆代表用例，线条人代表行为者，它们之间的连线表示关系。

1.系统
    系统被看作是一个提供用例的黑盒子，方框的边线表示系统的边界，描述该系统功能的用例置于方框内，代表外部实体的行为者置于方框外。

2.用例
     一个用例是可以被行为者感受到的、系统的一个完整的功能。在UML中把用例定义成系统完成的一系列动作，这些动作除了完成系统内部的计算与工作外，
     还包括与一些行为者的通信。用例通过关联与行为者连接，关联指出一个用例与哪些行为者交互，这种交互是双向的。
(1)用例代表某些用户可见的功能，实现一个具体的用户目标。
        (2)用例总是被行为者启动的，并向行为者提供可识别的值。
        (3)用例必须是完整的。

3.行为者
    行为者是指与系统交互的人或其他系统，它代表外部实体。
        行为者代表一种角色，而不是某个具体的人或物。一个具体的人可以充当多种不同角色。
        在用例图中用直线连接行为者和用例，表示行为者触发用例，并与用例交换信息。
        单个行为者可与多个用例联系；一个用例也可与多个行为者联系。

4.用例之间的关系
    
    (1) 扩展关系
    向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关系就是扩展关系，后者继承前者的一些行为，把后者称为扩展用例。

    (2) 使用关系
    当一个用例使用另一个用例时，这两个用例之间就构成了使用关系。一般说来，如果在若干个用例中有某些相同的动作，
    则可以把这些相同的动作提取出来单独构成一个用例（称为抽象用例）。

  这两种关系都意味着从几个用例中抽取那些公共的行为并放入一个单独的用例中。
       通常在描述一般行为的变化时采用扩展关系；在两个或多个用例中出现重复描述又想避免这种重复时，可以采用使用关系。

9.6.2.用例建模
1.寻找行为者
2.寻找用例

9.7   3种模型之间的关系
功能模型指明了系统应该“做什么”；
动态模型明确规定了什么时候(即在何种状态下接受了什么事件的触发)做；
对象模型则定义了做事情的实体。



















